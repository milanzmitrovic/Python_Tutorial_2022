# Python Tutorial 2022

## *** Materials for this course are comming from book [Python Crash Course](https://www.amazon.com/Python-Crash-Course-2nd-Edition/dp/1593279280) by Eric Matthes. 

## *** More information about Eric Matthes' book and [additional lecture materials](https://ehmatthes.github.io/pcc_2e/regular_index/) can be found on [book's website](https://ehmatthes.github.io/pcc_2e/) .

##


### Questions that we are going to answer regarding each new element we learn:
1. What is it?
2. What is it used for?
3. What can we do with it?
4. What are some alternatives?
5. Why do we need it?
6. What problems it solves to us?
7. What does it enable us to do?
8. How important it is?
9. Where does it fit in general CS/programming picture?
10. Imagine this programming element hadn't beed invented. 
  -  How could we replicate its behaviour? 
  -  What other elements can we use to get same results?
11. WHY question!!!
  - What do we want to achieve and as a consequence we need to use this programming concept/element?
  - What is our business idea whose translation into code requires use of this programming concept?
12. History!!!
  - What did people use before this concept/element was invented?

### Learning Tips
1. What is 'zero point'?
  - 'Zero piont' is programming concept that will not be explained.
  - It can't be explained easily.
  - It is something from which we start. We take it as granted.
  - We use it to explain other programming concepts and elements.
  - Analogy from mathematics is 'point'. There is no explanation of it. We just use it to explain more advanced elements (lines, planes, hyperplanes...)
  - Examples: integers, floats, letters, boolean values... We take it as granted, we already know what it is!
  
2. You will spend most of your (work)day on DEBUGGING i.e. figuring out why something does not work properly. 
  - Time that you spend on DEBUGGING will be even more than time used for modelling and conceptual thinking! 
  - So, be patient and get used to errors. Remember, error that is stopping you is better than hidden error. 
  - Also, integrating elements and making them work together is crucial part of DEBUGGING. Most of the time, it is 'try and error' type of work.

3. In real life, things are never happening as they are presented movies (in this case, videos produced by programming bootcamps).
  - In code development, there are no such a fancy and elegant things that are working from first attempt.
  - Try and error, experimenting and debugging are integral parts of development process.
  - Do not have wrong expectations that anything will work when you try it for the first time. Be happy if it works after 5 trials.
  - Do not pressure yourself with wrong expectations.
  - Let's 'normalize' work you devote to experimenting, debugging, combining elements and integrating things (making them work togather).
  - Work and time you spend on experimenting and debugging are in the heart of programming business. 
  - Debugging and experimenting accounts for more than 80% of developers hours.
  - So, instead of saying to yourself "let's have some code done", tell it "let's experiment, let's debug, let's have try and error session".

 4. How to organize your work and be efficient in long run?
  - Design system i.e. write sequence of simple steps that should be accomplished.
  - Focus on one step at a time.
  - Expect that things you planned to implement will not work first 5 attempts and devote enough time for experimenting and integrating things!!!

##
##

## 0. Intro

## 1. Concepts and Vocabulaty

#### 1.1 Programming Languages
#### 1.2 Operating Systems
#### 1.3 Terminal
#### 1.4 Text Editors
#### 1.5 IDEs
#### 1.6 Comments
#### 1.7 Style Guides
#### 1.8 Project Specification
#### 1.9 Syntax
#### 1.10 Debugging
#### 1.11 Refactoring
#### 1.12 Standard Library
#### 1.13 Third-Party Libraries
#### 1.14 Frameworks
#### 1.15 Error Handling
#### 1.16 Version Control
#### 1.17 Testing
#### 1.18 User Interfaces
#### 1.19 Databases
#### 1.20 Data Structures and Types
#### 1.21 Variables
#### 1.22 Strings
#### 1.23 Numerical Data Types
#### 1.24 Sequences
#### 1.25 Mappings 
#### 1.26 Functions
#### 1.27 Classes
#### 1.28 Inheritance
#### 1.29 Other Data Types
#### 1.30 if Statements
#### 1.31 Loop
#### 1.32 Modules
#### 1.33 Saving States

## 2. Simple Data Types

#### 2.1 Variables
#### 2.2 Strings
#### 2.3 String Methods
#### 2.4 Using Variables in Strings
#### 2.5 Comments
#### 2.6 Numerical Data
#### 2.7 Numerical Operations
#### 2.8 Working with Numerical Data
#### 2.9 Using Math Library

## 3. Lists and Tuples

#### 3.1 Lists
#### 3.2 Removing Items from Lists
#### 3.3 Slicing a List
#### 3.4 Copying a List
#### 3.5 Looping Through List
#### 3.6 Sorting List
#### 3.7 Reverse Sorting List
#### 3.8 Numerical Lists
#### 3.9 List Comprehensions
#### 3.10 Tuples

## 4. Dictionaries

#### 4.1 About Dictionaries
#### 4.2 Dictionary Methods
#### 4.3 Looping Through a Dictionary
#### 4.4 Example Dictionaries
#### 4.5 Nesting: A List of Dictionaries
#### 4.6 Nesting: A List in a Dictionary

## 5. Conditional Statements

#### 5.1 About Conditional Statements
#### 5.2 if Statements
#### 5.3 if-else Statements
#### 5.4 User Input
#### 5.5 while Loops
#### 5.6 The break and continue Statements

## 6. Functions

#### 6.1 About Functions
#### 6.2 Passing Arguments
#### 6.3 Positional Arguments
#### 6.4 Arbitrary Positional Arguments
#### 6.5 Keyword Arguments
#### 6.6 Arbitrary Keyword Arguments
#### 6.7 Default Values
#### 6.8 Return Values
#### 6.9 Modules
#### 6.10 Importing Functions
#### 6.11 Importing Specific Functions

## 7. Classes

#### 7.1 About Classes
#### 7.2 Methods
#### 7.3 Making Instances
#### 7.4 Adding Methods
#### 7.5 Multiple Instances
#### 7.6 Inheritance
#### 7.7 Child Class Methods
#### 7.8 Overriding Parent Class Methods
#### 7.9 Storing Classes in Modules

## 8. Testing

#### 8.1 unittest Module
#### 8.2 Testing Functions
#### 8.3 Running a Passing Test
#### 8.4 Running a Failing Test
#### 8.5 Fixing a Failing Test
#### 8.6 The setUp() Method

## 9. Packages

#### 9.1 Installing Packages
#### 9.2 Uninstalling Python Packages


